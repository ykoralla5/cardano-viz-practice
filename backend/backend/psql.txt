Materialized views

mv_epoch_delegator_stake: 
    WITH ranked AS (
         SELECT es.epoch_no,
            es.pool_id AS pool_id, // ADD THIS COLUMN
            ph.view AS pool_view,
            sa.view AS delegator_id,
            es.amount AS amount,
            sum(es.amount::numeric) OVER (PARTITION BY es.epoch_no, ph.view) AS pool_total,
            sum(es.amount::numeric) OVER (PARTITION BY es.epoch_no, ph.view ORDER BY es.amount DESC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS running_total
           FROM epoch_stake es
             JOIN pool_hash ph ON ph.id = es.pool_id
             JOIN stake_address sa ON sa.id = es.addr_id
        )
    SELECT ranked.epoch_no,
        ranked.pool_view,
        ranked.stake_addr_view,
        ranked.amount,
        ranked.pool_total,
        ranked.running_total
    FROM ranked
    WHERE ranked.running_total <= (ranked.pool_total * 0.5);

---------------------------------------------------------------------------------------------------------------------------------

mv_epoch_delegation_movements: shows delegation movements made from previous epoch

SELECT
    curr_epoch.epoch_no,
    curr_epoch.addr_id,
	st_add.view AS stake_addr_view,
	prev_epoch.pool_id AS source_pool_id,
	ph_prev.view AS source_pool_view,
	curr_epoch.pool_id AS destination_pool_id,
    ph_curr.view AS destination_pool_view,
    curr_epoch.amount AS amount
FROM epoch_stake prev_epoch
JOIN epoch_stake curr_epoch 
    ON prev_epoch.addr_id = curr_epoch.addr_id
   AND curr_epoch.epoch_no = prev_epoch.epoch_no + 1
JOIN pool_hash ph_prev ON ph_prev.id = prev_epoch.pool_id
JOIN pool_hash ph_curr ON ph_curr.id = curr_epoch.pool_id
JOIN stake_address st_add ON st_add.id = curr_epoch.addr_id
WHERE prev_epoch.pool_id <> curr_epoch.pool_id
ORDER BY curr_epoch.epoch_no, curr_epoch.addr_id;

---------------------------------------------------------------------------------------------------------------------------------

mv_epoch_pool_performance: actual, expected block count by pool and by Epoch. Ratio to be calculated on django
    WITH total_epoch_blocks AS (
        SELECT epoch_no, COUNT(block_no) AS active_slots FROM block GROUP BY epoch_no
    ),
    total_epoch_stake AS (
        SELECT
            epoch_no, SUM(amount) AS total_stake
        FROM epoch_stake
        GROUP BY epoch_no
    ),
    pool_epoch_blocks AS (
        SELECT 
            b.epoch_no, sl.pool_hash_id AS pool_id, COUNT(b.id) AS actual_blocks
        FROM block b
        JOIN slot_leader sl ON sl.id = b.slot_leader_id
        WHERE sl.pool_hash_id IS NOT NULL 
        GROUP BY b.epoch_no, sl.pool_hash_id
    ),
    pool_epoch_stake AS (
        SELECT
            epoch_no, pool_id, SUM(amount) AS pool_stake FROM epoch_stake GROUP BY epoch_no, pool_id
    )
    SELECT
        ep.epoch_no,
        ph.view AS pool_id,
        COALESCE(peb.actual_blocks) AS actual_blocks,
        ROUND(((teb.active_slots::numeric * (1 - ep.decentralisation::numeric) * pes.pool_stake::numeric)/ tes.total_stake::numeric),2) AS expected_blocks
    FROM epoch_param ep
    JOIN epoch_stake es ON es.epoch_no = ep.epoch_no
    JOIN pool_hash ph ON ph.id = es.pool_id
    JOIN total_epoch_blocks teb ON teb.epoch_no = ep.epoch_no
    JOIN total_epoch_stake tes ON teb.epoch_no = ep.epoch_no
    JOIN pool_epoch_stake pes ON pes.epoch_no = ep.epoch_no
    LEFT JOIN pool_epoch_blocks peb ON peb.epoch_no = ep.epoch_no AND peb.pool_id = pes.pool_id
    LEFT JOIN block b ON b.slot_leader_id = ph.id AND b.epoch_no = ep.epoch_no;

---------------------------------------------------------------------------------------------------------------------------------

mv_epoch_pool_stats: delegator count, saturation_ratio, pledge, is_active

    WITH pledge_at_snapshot AS (
        SELECT DISTINCT ON (ph.id, e.no) 
            ph.id AS pool_id,
            e.no AS epoch_no,
            pu.pledge
        FROM pool_hash ph
        JOIN pool_update pu ON pu.hash_id = ph.id
        JOIN tx t ON t.id = pu.registered_tx_id
        JOIN block b ON b.id = t.block_id
        JOIN epoch e ON b.time <= e.end_time
        ORDER BY ph.id, e.no, b.time DESC
    ),
    total_active AS (
        SELECT epoch_no, SUM(amount) AS total_active_stake
        FROM epoch_stake
        GROUP BY epoch_no
    )
    SELECT
        es.epoch_no,
        es.pool_id,
        ph.view AS pool_view,
        SUM(es.amount) AS total_stake,
        COUNT(DISTINCT es.addr_id) AS delegator_count,
        pledges.pledge,
        NOT EXISTS (
                SELECT 1
                FROM pool_retire pr
                WHERE pr.hash_id = es.pool_id
                AND pr.retiring_epoch <= es.epoch_no
            ) AS is_active,
        (SUM(es.amount) / (ta.total_active_stake / ep.optimal_pool_count)) AS saturation_ratio
    FROM epoch_stake es
    JOIN pool_hash ph ON ph.id = es.pool_id
    JOIN epoch_param ep ON ep.epoch_no = es.epoch_no
    JOIN total_active ta ON ta.epoch_no = es.epoch_no
    LEFT JOIN pledge_at_snapshot pledges
        ON pledges.pool_id = es.pool_id AND pledges.epoch_no = es.epoch_no
    GROUP BY es.epoch_no, es.pool_id, ph.view, pledges.pledge, ep.optimal_pool_count, ta.total_active_stake;

---------------------------------------------------------------------------------------------------------------------------------

mv_epoch_params: decentralisation, pledge influence, saturation point
    WITH total_active AS (
        SELECT
            epoch_no,
            SUM(amount) AS total_active_stake
        FROM epoch_stake
        GROUP BY epoch_no
    )
    SELECT 
		ep.epoch_no,
		ep.influence AS pledge_influence,
		ep.decentralisation,
    	(ta.total_active_stake / ep.optimal_pool_count) AS saturation_point
    FROM 
        epoch_param ep
    JOIN
        total_active ta ON ta.epoch_no = ep.epoch_no;

---------------------------------------------------------------------------------------------------------------------------------

mv_epoch_stats_gini: gini coefficient
WITH pool_stakes AS (
    SELECT
        epoch_no,
        pool_id,
        amount,
        SUM(amount) OVER (PARTITION BY epoch_no) AS total_stake,
        ROW_NUMBER() OVER (PARTITION BY epoch_no ORDER BY amount ASC) AS rank_asc,
        COUNT(amount) OVER (PARTITION BY epoch_no) AS num_pools
    FROM
        epoch_stake
    WHERE
        epoch_no >= 209
),
gini_calc AS (
    SELECT
        epoch_no,
        num_pools,
        total_stake,
        SUM(rank_asc * amount) AS sum_product_rank_stake
    FROM
        pool_stakes
    GROUP BY
        epoch_no, num_pools, total_stake
)
SELECT
    epoch_no,
    (2 * sum_product_rank_stake / (num_pools * total_stake)) - ((num_pools + 1.0) / num_pools) AS gini_coefficient
FROM
    gini_calc
ORDER BY
    epoch_no DESC;

---------------------------------------------------------------------------------------------------------------------------------

mv_epoch_stats_nakamoto: nakamoto coefficient
WITH pool_stakes_ranked AS (
    SELECT
        epoch_no,
        pool_id,
        amount,
        SUM(amount) OVER (PARTITION BY epoch_no) AS total_stake,
        SUM(amount) OVER (PARTITION BY epoch_no ORDER BY amount DESC) AS cumulative_stake
    FROM
        epoch_stake
    WHERE
        epoch_no >= 209
),
nakamoto_calc AS (
    SELECT
        epoch_no,
        COUNT(pool_id) AS nakamoto_coefficient
    FROM
        pool_stakes_ranked
    WHERE
        cumulative_stake > total_stake * 0.5
    GROUP BY
        epoch_no
)
SELECT
    epoch_no,
    nakamoto_coefficient
FROM
    nakamoto_calc
ORDER BY
    epoch_no DESC;