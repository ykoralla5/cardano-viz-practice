Materialized views

mv_epoch_delegator_stake_v2: delegators contributing to the top 50% of the pool
    WITH ranked AS (
         SELECT es.epoch_no,
            es.pool_id AS pool_id,
            ph.view AS pool_view,
            es.addr_id AS stake_addr_id,
            sa.view AS stake_addr_view,
            es.amount AS amount,
            sum(es.amount::numeric) OVER (PARTITION BY es.epoch_no, ph.view) AS pool_total,
            sum(es.amount::numeric) OVER (PARTITION BY es.epoch_no, ph.view ORDER BY es.amount DESC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS running_total
           FROM epoch_stake es
             JOIN pool_hash ph ON ph.id = es.pool_id
             JOIN stake_address sa ON sa.id = es.addr_id
        )
    SELECT ranked.epoch_no,
        ranked.pool_id,
        ranked.pool_view,
        ranked.stake_addr_id,
        ranked.stake_addr_view,
        ranked.amount,
        ranked.pool_total,
        ranked.running_total
    FROM ranked
    WHERE ranked.running_total <= (ranked.pool_total * 0.5) ORDER BY epoch_no, pool_total DESC;

    CREATE UNIQUE INDEX ON mv_epoch_delegator_stake_v2 (epoch_no, pool_id, stake_addr_id);

---------------------------------------------------------------------------------------------------------------------------------
mv_epoch_delegation_movement_counts: example format:
[
  {"from": "PoolA", "to": "PoolB", "count": 30},
  {"from": "PoolB", "to": "PoolA", "count": 20},
  {"from": "PoolA", "to": "PoolC", "count": 15},
  {"from": "PoolC", "to": "PoolB", "count": 5}
]

    SELECT
        epoch_no,
        source_pool_id,
        source_pool_view,
        destination_pool_id,
        destination_pool_view,
        COUNT(*) AS movement_count
    FROM mv_epoch_delegation_movements
    WHERE source_pool_id IS NOT NULL
    AND destination_pool_id IS NOT NULL
    AND source_pool_id <> destination_pool_id
    GROUP BY epoch_no, source_pool_id, destination_pool_id, source_pool_view, destination_pool_view ORDER BY epoch_no, movement_count DESC;

    CREATE UNIQUE INDEX ON mv_epoch_delegation_movement_counts (epoch_no, source_pool_id, destination_pool_id);

V2: mv_epoch_delegation_movement_amounts_counts (with amounts)
    SELECT
        epoch_no,
        source_pool_id,
        source_pool_view,
        destination_pool_id,
        destination_pool_view,
		COUNT(*) AS movement_counts,
        SUM(amount) AS movement_amount
    FROM mv_epoch_delegation_movements
    WHERE source_pool_id IS NOT NULL
    AND destination_pool_id IS NOT NULL
    AND source_pool_id <> destination_pool_id
    GROUP BY epoch_no, source_pool_id, destination_pool_id, source_pool_view, destination_pool_view ORDER BY epoch_no, movement_amount DESC;

---------------------------------------------------------------------------------------------------------------------------------

mv_epoch_delegation_movements: shows delegation movements made from previous epoch

    SELECT
        curr_epoch.epoch_no,
        curr_epoch.addr_id,
        st_add.view AS stake_addr_view,
        prev_epoch.pool_id AS source_pool_id,
        ph_prev.view AS source_pool_view,
        curr_epoch.pool_id AS destination_pool_id,
        ph_curr.view AS destination_pool_view,
        curr_epoch.amount AS amount
    FROM epoch_stake prev_epoch
    JOIN epoch_stake curr_epoch 
        ON prev_epoch.addr_id = curr_epoch.addr_id
    AND curr_epoch.epoch_no = prev_epoch.epoch_no + 1
    JOIN pool_hash ph_prev ON ph_prev.id = prev_epoch.pool_id
    JOIN pool_hash ph_curr ON ph_curr.id = curr_epoch.pool_id
    JOIN stake_address st_add ON st_add.id = curr_epoch.addr_id
    WHERE prev_epoch.pool_id <> curr_epoch.pool_id
    ORDER BY curr_epoch.epoch_no, curr_epoch.addr_id;

    CREATE UNIQUE INDEX unique_mv_epoch_del_mov ON mv_epoch_delegation_movements (epoch_no, addr_id);

---------------------------------------------------------------------------------------------------------------------------------

mv_epoch_pool_performance: actual, expected block count by pool and by Epoch. Ratio to be calculated on django
    WITH total_epoch_blocks AS (
        SELECT epoch_no, COUNT(block_no) AS active_slots FROM block GROUP BY epoch_no
    ),
    total_epoch_stake AS (
        SELECT
            epoch_no, SUM(amount) AS total_stake
        FROM epoch_stake
        GROUP BY epoch_no
    ),
    pool_epoch_blocks AS (
        SELECT 
            b.epoch_no, sl.pool_hash_id AS pool_id, COUNT(b.id) AS actual_blocks
        FROM block b
        JOIN slot_leader sl ON sl.id = b.slot_leader_id
        WHERE sl.pool_hash_id IS NOT NULL 
        GROUP BY b.epoch_no, sl.pool_hash_id
    ),
    pool_epoch_stake AS (
        SELECT
            epoch_no, pool_id, SUM(amount) AS pool_stake FROM epoch_stake GROUP BY epoch_no, pool_id
    )
    SELECT
        ep.epoch_no,
        ph.view AS pool_id,
        COALESCE(peb.actual_blocks) AS actual_blocks,
        ROUND(((teb.active_slots::numeric * (1 - ep.decentralisation::numeric) * pes.pool_stake::numeric)/ tes.total_stake::numeric),2) AS expected_blocks
    FROM epoch_param ep
    JOIN epoch_stake es ON es.epoch_no = ep.epoch_no
    JOIN pool_hash ph ON ph.id = es.pool_id
    JOIN total_epoch_blocks teb ON teb.epoch_no = ep.epoch_no
    JOIN total_epoch_stake tes ON teb.epoch_no = ep.epoch_no
    JOIN pool_epoch_stake pes ON pes.epoch_no = ep.epoch_no
    LEFT JOIN pool_epoch_blocks peb ON peb.epoch_no = ep.epoch_no AND peb.pool_id = pes.pool_id
    LEFT JOIN block b ON b.slot_leader_id = ph.id AND b.epoch_no = ep.epoch_no;

    CREATE UNIQUE INDEX ON mv_epoch_pool_performance (epoch_no, pool_id);

---------------------------------------------------------------------------------------------------------------------------------

mv_epoch_pool_stats: delegator count, saturation_ratio, pledge, is_active

    WITH pledge_at_snapshot AS (
        SELECT DISTINCT ON (ph.id, e.no) 
            ph.id AS pool_id,
            e.no AS epoch_no,
            pu.pledge
        FROM pool_hash ph
        JOIN pool_update pu ON pu.hash_id = ph.id
        JOIN tx t ON t.id = pu.registered_tx_id
        JOIN block b ON b.id = t.block_id
        JOIN epoch e ON b.time <= e.end_time
        ORDER BY ph.id, e.no, b.time DESC
    ),
    total_active AS (
        SELECT epoch_no, SUM(amount) AS total_active_stake
        FROM epoch_stake
        GROUP BY epoch_no
    )
    SELECT
        es.epoch_no,
        es.pool_id,
        ph.view AS pool_view,
        SUM(es.amount) AS total_stake,
        COUNT(DISTINCT es.addr_id) AS delegator_count,
        pledges.pledge,
        NOT EXISTS (
                SELECT 1
                FROM pool_retire pr
                WHERE pr.hash_id = es.pool_id
                AND pr.retiring_epoch <= es.epoch_no
            ) AS is_active,
        (SUM(es.amount) / (ta.total_active_stake / ep.optimal_pool_count)) AS saturation_ratio
    FROM epoch_stake es
    JOIN pool_hash ph ON ph.id = es.pool_id
    JOIN epoch_param ep ON ep.epoch_no = es.epoch_no
    JOIN total_active ta ON ta.epoch_no = es.epoch_no
    LEFT JOIN pledge_at_snapshot pledges
        ON pledges.pool_id = es.pool_id AND pledges.epoch_no = es.epoch_no
    GROUP BY es.epoch_no, es.pool_id, ph.view, pledges.pledge, ep.optimal_pool_count, ta.total_active_stake;

    CREATE UNIQUE INDEX ON mv_epoch_pool_stats (epoch_no, pool_id);

---------------------------------------------------------------------------------------------------------------------------------

mv_epoch_params: decentralisation, pledge influence, saturation point
    WITH total_active AS (
        SELECT
            epoch_no,
            SUM(amount) AS total_active_stake
        FROM epoch_stake
        GROUP BY epoch_no
    )
    SELECT 
		ep.epoch_no,
		ep.influence AS pledge_influence,
		ep.decentralisation,
    	(ta.total_active_stake / ep.optimal_pool_count) AS saturation_point
    FROM 
        epoch_param ep
    JOIN
        total_active ta ON ta.epoch_no = ep.epoch_no;

    CREATE UNIQUE INDEX ON mv_epoch_params (epoch_no);

---------------------------------------------------------------------------------------------------------------------------------

mv_epoch_stats_gini: gini coefficient
    WITH pool_stakes AS (
        SELECT
            epoch_no,
            pool_id,
            amount,
            SUM(amount) OVER (PARTITION BY epoch_no) AS total_stake,
            ROW_NUMBER() OVER (PARTITION BY epoch_no ORDER BY amount ASC) AS rank_asc,
            COUNT(amount) OVER (PARTITION BY epoch_no) AS num_pools
        FROM
            epoch_stake
        WHERE
            epoch_no >= 209
    ),
    gini_calc AS (
        SELECT
            epoch_no,
            num_pools,
            total_stake,
            SUM(rank_asc * amount) AS sum_product_rank_stake
        FROM
            pool_stakes
        GROUP BY
            epoch_no, num_pools, total_stake
    )
    SELECT
        epoch_no,
        (2 * sum_product_rank_stake / (num_pools * total_stake)) - ((num_pools + 1.0) / num_pools) AS gini_coefficient
    FROM
        gini_calc
    ORDER BY
        epoch_no DESC;

    CREATE UNIQUE INDEX ON mv_epoch_stats_gini (epoch_no);

---------------------------------------------------------------------------------------------------------------------------------

mv_epoch_stats_nakamoto: nakamoto coefficient
    WITH pool_stakes_ranked AS (
        SELECT
            epoch_no,
            pool_id,
            amount,
            SUM(amount) OVER (PARTITION BY epoch_no) AS total_stake,
            SUM(amount) OVER (PARTITION BY epoch_no ORDER BY amount DESC) AS cumulative_stake
        FROM
            epoch_stake
        WHERE
            epoch_no >= 209
    ),
    nakamoto_calc AS (
        SELECT
            epoch_no,
            COUNT(pool_id) AS nakamoto_coefficient
        FROM
            pool_stakes_ranked
        WHERE
            cumulative_stake > total_stake * 0.5
        GROUP BY
            epoch_no
    )
    SELECT
        epoch_no,
        nakamoto_coefficient
    FROM
        nakamoto_calc
    ORDER BY
        epoch_no DESC;

    CREATE UNIQUE INDEX ON mv_epoch_stats_nakamoto (epoch_no);


CREATE MATERIALIZED VIEW mv_pledge_at_snapshot AS
SELECT DISTINCT ON (ph.id, e.no) 
    ph.id AS pool_id,
    e.no AS epoch_no,
    pu.pledge
FROM pool_hash ph
JOIN pool_update pu ON pu.hash_id = ph.id
JOIN tx t ON t.id = pu.registered_tx_id
JOIN block b ON b.id = t.block_id
JOIN epoch e ON b.time <= e.end_time
ORDER BY ph.id, e.no, b.time DESC;

CREATE MATERIALIZED VIEW mv_total_active_stake AS
SELECT epoch_no, SUM(amount) AS total_active_stake
FROM epoch_stake
GROUP BY epoch_no;

CREATE MATERIALIZED VIEW mv_last_stake_before_retire AS
SELECT
    es.pool_id,
    pr.retiring_epoch,
    SUM(es.amount) AS last_stake
FROM pool_retire pr
JOIN epoch_stake es
  ON es.pool_id = pr.hash_id
 AND es.epoch_no = pr.retiring_epoch - 1
GROUP BY es.pool_id, pr.retiring_epoch;

WITH total_active AS (
    SELECT epoch_no, SUM(amount) AS total_active_stake
    FROM epoch_stake
    GROUP BY epoch_no
),
prev_epoch_stake AS (
    SELECT
        es.epoch_no + 1 AS epoch_no,
        es.pool_id,
        SUM(es.amount) AS prev_total_stake
    FROM epoch_stake es
    GROUP BY es.epoch_no + 1, es.pool_id
)
SELECT
    base.epoch_no,
    base.pool_id,
    ph.view AS pool_view,
    -- adjusted stake
    CASE
        WHEN NOT is_active
         AND COUNT(DISTINCT es.addr_id) = 0
        THEN pes.prev_total_stake
        ELSE SUM(es.amount)
    END AS adjusted_total_stake,
    -- delegators
    CASE
        WHEN NOT is_active
         AND COUNT(DISTINCT es.addr_id) = 0
        THEN 0
        ELSE COUNT(DISTINCT es.addr_id)
    END AS delegator_count,
    ps.pledge,
    is_active,
    CASE
        WHEN NOT is_active
         AND COUNT(DISTINCT es.addr_id) = 0
        THEN 'full_retirement'
        WHEN NOT is_active
         AND COUNT(DISTINCT es.addr_id) > 0
        THEN 'partial_retirement'
        ELSE 'active'
    END AS retirement_case,
    (CASE
        WHEN NOT is_active
         AND COUNT(DISTINCT es.addr_id) = 0
        THEN pes.prev_total_stake
        ELSE SUM(es.amount)
     END) / (ta.total_active_stake / ep.optimal_pool_count) AS saturation_ratio
FROM (
    SELECT DISTINCT e.no AS epoch_no, ph.id AS pool_id
    FROM epoch e
    CROSS JOIN pool_hash ph
) base
JOIN pool_hash ph ON ph.id = base.pool_id
JOIN epoch_param ep ON ep.epoch_no = base.epoch_no
JOIN total_active ta ON ta.epoch_no = base.epoch_no
LEFT JOIN epoch_stake es
       ON es.pool_id = base.pool_id AND es.epoch_no = base.epoch_no
LEFT JOIN prev_epoch_stake pes
       ON pes.epoch_no = base.epoch_no AND pes.pool_id = base.pool_id
LEFT JOIN mv_pledge_at_snapshot ps
       ON ps.pool_id = base.pool_id AND ps.epoch_no = base.epoch_no
LEFT JOIN pool_retire pr
       ON pr.hash_id = base.pool_id
     AND pr.retiring_epoch <= base.epoch_no where base.epoch_no=560 and base.pool_id=3564
GROUP BY base.epoch_no, base.pool_id, ph.view, ps.pledge,
         ep.optimal_pool_count, ta.total_active_stake,
         pes.prev_total_stake,
         (pr.hash_id IS NULL)
HAVING SUM(es.amount) IS NOT NULL
    OR (NOT (pr.hash_id IS NULL)); -- keep ghost pools
